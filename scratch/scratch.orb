module Orb::Core::Types {
    type Unit
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }
}

module Orb::Core::Numbers with Orb::Core::Errors {
    type Int
    type Real

    projection Int : Error
}

module Orb::Core::Errors {
    trait Error
}

module Orb::More::Attributes::Intrinsics {
    attribute KindEquals = (A, B) => A ^ B
    attribute TypeEquals = (A, B) => A = B
    attribute Implements = (A, B) => A : B

    attribute AnyTypeArrow = (F) => .KindEquals(F, (_) => {})
    attribute AnyArrow = (F) => .TypeEquals(F, (Any) -> Any)
}

module Main with Orb::* {
    attribute Check = (A, B) => A = B

    alias Option = (V) => (Some: { value V } | None: {=})
    alias Either = (L, R) => (Left: L | Right: R)
    alias Choice = (A, B) => A where .Check(A, B) else .Either(A, B)

    context OptionCtx [ValueType] {
        fun (self .Option(ValueType)) force () (ValueType) = select self {
            case Some(value) = value
            case None = panic 0
        }

        postfix operator forceUnwrap `!` by ::force
    }

    context CoalesceCtx [ValueType, FallbackType] {
        alias LocalOption = .Option(ValueType)
        alias LocalChoice = .Choice(ValueType, FallbackType)

        fun (self LocalOption) coalesce (fallback FallbackType) (LocalChoice) = select self {
            case Some(value) = value
            case None = fallback
        }

        infix operator coalesceFallback `??` by ::coalesce
    }

    fun (Any) main () () {
        opt = Some(1)
        opt2 = Some(true)

        typeOf opt.coalesce(true)
        typeOf opt2.coalesce(0)

        typeOf opt!
        typeOf opt2!

        typeOf opt.force()
        typeOf opt2.force()
    }
}