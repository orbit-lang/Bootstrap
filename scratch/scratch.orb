module Orb::Core::Numbers {
    type Int
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }

    (self Bool) and (other Bool) (Bool) = select self {
        case true = other
        case else = false
    }

    (self Bool) or (other Bool) (Bool) = select self {
        case true = true
        case else = other
    }

    (self Bool) not () (Bool) = select self {
        case true = false
        case else = true
    }

    infix operator boolAnd `&&` by Bool::and
    infix operator boolOr  `||` by Bool::or
    prefix operator boolNot `!` by Bool::not
}

module Orb::Core::Types {
    type Unit
    trait Any
}

module M with Orb::Core::* {
    alias Point = { x Int, y Int }

    (self Int) pow (exponent Int) (Int) = self
    (self Int) squared () (Int) = self.pow(2)

    infix operator powerOf `power of` by Int::pow
    postfix operator squared `squared` by Int::squared

#    (Int) one (i expand 0, j expand 1) (expand 1) = j

#    infix operator plus `+` by Int::one
#
#    trait IntConstant {
#        (self Self) constValue () (Int)
#    }

#    projection expand 0 : IntConstant
#        with constValue by { expand 0 }
#
#    projection expand 1 : IntConstant
#        with constValue by { expand 1 }

#    context AddCtx [n Int, m Int] {
#        (Int) add (i expand n)
#    }

    alias Foo = { value Int }

    (Unit) main () () {
        z = expand 0
        s = expand Foo(expand 1)

        typeOf s.value
    }
}
