module Orb::Core::Numbers {
    type Int
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }

    (self Bool) and (other Bool) (Bool) = select self {
        case true = other
        case else = false
    }

    (self Bool) or (other Bool) (Bool) = select self {
        case true = true
        case else = other
    }

    (self Bool) not () (Bool) = select self {
        case true = false
        case else = true
    }

    infix operator boolAnd `&&` by Bool::and
    infix operator boolOr  `||` by Bool::or
    prefix operator boolNot `!` by Bool::not
}

module Orb::Core::Types {
    type Unit
    trait Any
}

module M with Orb::Core::* {
    context TupleCtx [A, B] with alias Tuple = (A, B)
    context BoxCtx [A] {
        alias Box = { value A }

        (self Box) unbox () (A) = A()
    }

    context TripleCtx [A, B, C]
        with alias Triple = { a A, b B, c C }

    context UnoCtx [A] {
        type Uno

        (Uno) new () (Uno) = Uno()
    }

    (Int) main () () {
        i = Tuple(1, false)
        j = Tuple(true, 0)

        b1 = Box(1)
        b2 = Box(b1)

        typeOf b1.unbox()

        t1 = Triple(1, 2, 3)
        t2 = Triple(t1, 2, false)

        typeOf t1
        typeOf t2

        u = Uno.new()

        typeOf u
    }
}