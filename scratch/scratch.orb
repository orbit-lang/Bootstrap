module Orb::Core::Types {
    type Unit
}

module Orb::Core::Numbers {
    type Int
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }

    (self Bool) not () (Bool) = select self {
        case true = false
        case else = true
    }
}

module M with Orb::* {
    context FunctionCompositionContext [A, B, C] {
        (f (A) -> B) compose (g (B) -> C) ((A) -> C) = { a -> g(f(a)) }

        infix operator functionCompose `•` by ::compose
    }

    (Bool) main () () {
        fn1 = { (x Int) -> x }
        fn2 = { (y Int) -> y }
        fn3 = fn1 • fn2 within FunctionCompositionContext [Int, Int, Int]

        typeOf fn3
    }
}