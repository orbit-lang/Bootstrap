module Orb::Core::Types {
    type Unit of unit
}

module Orb::Core::Errors {
    trait Error
}

module Orb::Core::Booleans {
    type Bool of true, false

    fun (self Bool) not () (Bool) = select self {
        case .true = .false
        case .false = .true
    }

    fun (self Bool) and (other Bool) (Bool) = select (self, other) {
        case (.true, .true) = .true
        case else = .false
    }

    fun (self Bool) or (other Bool) (Bool) = select (self, other) {
        case (.true, .true) = .true
        case (.true, .false) = .true
        case (.false, .true) = .true
        case (.false, .false) = .false
    }

    fun (self Bool) same (other Bool) (Bool) = select (self, other) {
        case (.true, .true) = .true
        case (.false, .false) = .false
        case else = .false
    }

    prefix operator notOp `!` by ::not
    infix operator andOp `&&` by ::and
    infix operator orOp `||` by ::or
}

module Orb::Core::Numbers {
    type Int
}

module Orb::More::Fx {
    context FlowCtx [ResultType] {
        type Flow

        fun (self Flow) resume (value ResultType) (ResultType) = value
    }
}

module M with Orb::Core::* with Orb::More::* {
    projection ${0} : Error

    effect Throw = (Error) -> Unit
    effect IO = () -> Unit

    fun (Unit) foo () (Unit with Throw, IO) = .unit

    fun (Unit) main () () {
        Unit.foo() by { flow ->
            case Throw(error) = flow.resume(.unit)
            case IO = flow.resume(.unit)
        }
    }
}