module Orb::Core::Types {
    type Unit
}

module Orb::Core::Numbers {
    type Int
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }

    (self Bool) not () (Bool) = select self {
        case true = false
        case else = true
    }
}

module M with Orb::* {
    context FunctionCtx [A, B] {
        alias Function = (A) -> B
    }

    context FunctionCompositionContext [A, B, C] {
        (f (A) -> B) compose (g (B) -> C) ((A) -> C) = { a -> g(f(a)) }

        infix operator functionCompose `•` by ::compose
    }

    (self Int) next () (Int) = self + 1

    (Bool) main () () {
        fn1 = { x -> x }
        fn2 = { y -> y }
        fn3 = { x -> x } • { x -> x } within FunctionCompositionContext [Bool, Bool, Int]
        fn4 = ::next • { x -> x } within FunctionCompositionContext [Int, Int, Int]

        typeOf fn3
    }
}