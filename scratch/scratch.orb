module Orb::Core::Types {
    type Unit
}

module Orb::Core::Numbers {
    type Int
    type Real
}

module TypeFunctions with Orb::* {
    alias ID = (T) => T
#    alias Exactly = (variadic T, N Int) => select .T() where N = Int
#    alias Tuple = (variadic T) => T where .Exactly(T, 1)

    attribute KindEqual = (T, K) => T ^ K
#    attribute Invokable = (A) => .KindEqual(A, (*) => *)
    attribute Equal = (A, B) => A = B
    attribute Same = (A, B) => .Equal(A, B) | .Equal(B, A)

    alias Check = (A, B) => * where .Same(A, B)
#    alias CanInvoke = (F) => * where .Invokable(F)

#    alias Arrow = (A, B) => (A) -> B
#    alias Apply = (F) => (A) => .F(A) where arrow(F)
#
#    trait Foo(bar Int)

#    context FunctorCtx [F, A, B] where F ^ (*) -> * {
#        trait Functor {
#            fun (self .F(A)) map (f .Arrow(A, B)) (.F(B))
#        }
#    }

#    projection Int : Foo
#        with bar = 1

    fun (Unit) main () () {
        c = .Check(Int, Int)()
#        c = .CanInvoke(Int)()
    }
}