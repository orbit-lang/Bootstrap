module Orb::Core::Types {
    type Unit
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }
}

module Orb::Core::Numbers with Orb::Core::Errors {
    type Int
    type Real

    projection Int : Error
}

module Orb::Core::Errors {
    trait Error
}

module Orb::More::Attributes::Intrinsics {
    attribute CheckKinds = (A, B) => A ^ B
    attribute CheckTypes = (A, B) => A = B
    attribute CheckTrait = (A, B) => A : B
}

module Main with Orb::* {
    attribute Check = (A, B) => A = B

    alias Option = (V) => (Some: { value V } | None: {})
    alias Either = (L, R) => (Left: L | Right: R)
    alias Choice = (A, B) => A where .Check(A, B) else .Either(A, B)

    context OptionCtx [ValueType] {
        fun (self .Option(ValueType)) force () (ValueType) = select self {
            case Some(value) = value
            case None = panic 0
        }

        postfix operator forceUnwrap `!` by ::force
    }

    context CoalesceCtx [ValueType, FallbackType] {
        alias LocalOption = .Option(ValueType)
        alias LocalChoice = .Choice(ValueType, FallbackType)

        fun (self LocalOption) coalesce (fallback FallbackType) (LocalChoice) = select self {
            case Some(value) = value
            case None = fallback
        }

        infix operator coalesceFallback `??` by ::coalesce
    }

    fun (Any) main () () {
        opt = ${None()}

        typeOf opt!
    }
}