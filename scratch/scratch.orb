module Orb::Core::Types {
    type Unit
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }
}

module Orb::Core::Numbers {
    type Int
    type Real
}

module Orb::Core::Errors {
    trait Error
}

module Main with Orb::Core::* {
    type Nothing

    projection Int : Error

    context OptionCtx [Value] {
        alias Option = (None: () => {} | Some: { value Value })

        fun (self Option) force () (Value) = select self {
            case Some(value) = value
            case None = panic 0
        }

        postfix operator forceUnwrap `!` by ::force
    }

    alias Foo = { x Int, y Int }

    fun (self Foo) bar () (Int) = select self {
        case Foo(x, y) = x * y
        case else = 0
    }

    fun (Any) main () () {
        opt = Some(1)
        s = opt! within OptionCtx [Int]

        typeOf s
    }
}