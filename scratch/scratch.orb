module Orb::Core::Numbers {
    type Int
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }

    (self Bool) and (other Bool) (Bool) = select self {
        case true = other
        case else = false
    }

    (self Bool) or (other Bool) (Bool) = select self {
        case true = true
        case else = other
    }

    (self Bool) not () (Bool) = select self {
        case true = false
        case else = true
    }

    infix operator boolAnd `&&` by Bool::and
    infix operator boolOr  `||` by Bool::or
    prefix operator boolNot `!` by Bool::not
}

module Orb::Core::Types {
    type Unit
    trait Any
}

module M with Orb::Core::* {
    trait IntRepresentable {
        (self Self) intValue () (Int)
    }

    trait AnyRepresentable {
        (self Self) anyValue () (Any)
    }

    context BoxCtx [V] where V : IntRepresentable where V : AnyRepresentable {
        alias Box = { value V }

        projection Box : IntRepresentable
            with intValue by { 0 }

        projection Box : AnyRepresentable
            with anyValue by { 0 }

        projection Box : Any
    }

    context TupleContext [A, B, C] {
        alias Tuple = { b B, c C }
        alias AThing = { a A }
    }

    projection Int : IntRepresentable
        with intValue by { 0 }

    projection Int : Any
    projection Int : AnyRepresentable
        with anyValue by { 1 }

    (Unit) main () () {
        b1 = Box(1)
        b2 = Box(b1)

        a1 = AThing(1)
        a2 = AThing(a1)

        typeOf a1
        typeOf a2
    }
}
