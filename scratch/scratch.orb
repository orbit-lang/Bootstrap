module Orb::Core::Numbers {
    type Int
}

module Orb::Core::Booleans {
    type Bool {
        constructor True
        constructor False
    }

    (self Bool) and (other Bool) (Bool) = select self {
        case true = other
        case else = false
    }

    (self Bool) or (other Bool) (Bool) = select self {
        case true = true
        case else = other
    }

    (self Bool) not () (Bool) = select self {
        case true = false
        case else = true
    }

    infix operator boolAnd `&&` by Bool::and
    infix operator boolOr  `||` by Bool::or
    prefix operator boolNot `!` by Bool::not
}

module Orb::Core::Types {
    type Unit
    trait Any
}

module M with Orb::Core::* {
    alias Foo = { x Int, y Int }

#    (self Foo) bar () (Int) = self

    (Int) fib (n Int) (Int) = select n {
        case 0 = 1
        case 1 = 1
        case else = Int.fib(n - 1) + Int.fib(n - 2)
    }

    (Unit) main () () {
        f = Foo(1, 2)
    }

    trait Factory {
        (Self) build () (Self)
    }

    context AutoFactory [T, t T] {
        projection T : Factory
            with build by { t }
    }

    context TupleCtx [A] with alias Tuple = (A, A)

    (Int) main () () within TupleCtx [Int] & TupleCtx [Bool] {
        i = Tuple(1, 2)
    }
}