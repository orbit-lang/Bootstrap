module Orb::Core::Types {
    type Unit
}

module Orb::Core::Numbers {
    type Int
    type Real
}

module TypeFunctions with Orb::* {
    alias ID = (T) => T
#    alias Exactly = (variadic T, N Int) => select .T() where N = Int
#    alias Tuple = (variadic T) => T where .Exactly(T, 1)

    attribute KindEqual = (T, K) => T ^ K
    attribute Invokable = (A) => .KindEqual(A, (*) -> *)
    attribute Equal = (A, B) => A = B

    alias Same = (A, B) => A where .Equal(A, B)

#    alias Arrow = (A, B) => (A) -> B
#    alias Apply = (F) => (A) => .F(A) where arrow(F)
#
#    trait Foo(bar Int)

#    context FunctorCtx [F, A, B] where F ^ (*) -> * {
#        trait Functor {
#            fun (self .F(A)) map (f .Arrow(A, B)) (.F(B))
#        }
#    }

#    projection Int : Foo
#        with bar = 1

    fun (Unit) main () () {
#        f = Functor()
    }
}