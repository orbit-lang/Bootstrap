package org.orbit.backend

import java.lang.RuntimeException
import java.util.*

interface Numeric<N: Number> {
    val value: N

    operator fun plus(other: N) : N
}

data class OrbInt(override val value: Int) : Numeric<Int> {
    override fun plus(other: Int): Int = this.value + other
}

data class OrbDouble(override val value: Double) : Numeric<Double> {
    override fun plus(other: Double): Double = this.value + other
}

interface Instruction {
    val opCode: Byte

    fun execute(vm: VM)
}

interface ImmediateInstruction<T> : Instruction {
    val data: T
}

class Push<T: Any>(override val data: T) : ImmediateInstruction<T> {
    override val opCode: Byte = 0x10

    override fun execute(vm: VM) {
        vm.push(data)
    }
}

class Add<N: Number> : Instruction {
    override val opCode: Byte = 0x11

    override fun execute(vm: VM) {
        val i = vm.pop<Numeric<N>>()
        val j = vm.pop<Numeric<N>>()

        vm.push(i.plus(j.value))
    }
}

class Jump(private val address: Int) : Instruction {
    override val opCode: Byte = 0x20

    override fun execute(vm: VM) {
        vm.moveProgramCounter(address)
    }
}

class JumpLabel(private val label: String) : Instruction {
    override val opCode: Byte = 0x21

    override fun execute(vm: VM) {
        vm.moveProgramCounter(label)
    }
}

object PrintHead : Instruction {
    override val opCode: Byte = 0x02

    override fun execute(vm: VM) {
        val head = vm.pop<Any>()
        println(head)
    }
}

class Mark(val label: String) : Instruction {
    override val opCode: Byte = 0x03

    override fun execute(vm: VM) {}
}

object Examine : Instruction {
    override val opCode: Byte = 0x00

    override fun execute(vm: VM) {
        println(vm.stack)
    }
}

typealias Word = Short

interface Section {
    val name: String

    fun dump() : String
}

class MetaSection : Section {
    override val name: String = ".meta"
    private val timestamp: Long = System.currentTimeMillis()

    override fun dump(): String = """
        // Autogenerated OrbVM file
        // Generated @ $timestamp
        $name
    """.trimIndent()
}

class DataSection(private val stringConstants: List<String>) : Section {
    override val name: String = ".data"

    override fun dump(): String = """
    $name
    ${stringConstants.joinToString("\n") { "const '$it'" }}

    """.trimIndent()
}

class VM(stringConstants: List<String>, private val program: List<Instruction>) {
    private var programCounter: Int = -1
    private val metaSection = MetaSection()
    private val dataSection = DataSection(stringConstants)

    val stack = Stack<Any>()
    val labels = mutableMapOf<String, Int>()

    fun crash(reason: String) {
        throw RuntimeException(reason)
    }

    fun push(value: Any) {
        stack.push(value)
    }

    inline fun <reified T> pop() : T {
        if (stack.isEmpty()) crash("Stack integrity error: empty")

        return stack.pop() as T
    }

    fun mark(label: String, address: Int) {
        labels[label] = address
    }

    fun moveProgramCounter(address: Int) {
        programCounter = address
    }

    fun moveProgramCounter(label: String) {
        programCounter = labels[label] ?: throw RuntimeException("Label '${label}' not defined")
    }

    fun dump() : String {
        var str = "${metaSection.dump()}\n"
        str += "${dataSection.dump()}\n"

        var i = 0
        for (instruction in program) {
            val isLabel = labels.values.contains(i)

            val text: String = if (isLabel) {
                // There must be a missing label here
                "$i: " + labels.filter { it.value == i }.keys.first()
            } else {
                when (instruction) {
                    is ImmediateInstruction<*> ->
                        "$i: ${instruction::class.java.simpleName.toLowerCase()} ${instruction.data}"
                    else ->
                        "$i: ${instruction::class.java.simpleName.toLowerCase()}"
                }
            }

            str += text + "\n"

            i++
        }

        return str
    }

    fun run() {
        program.mapIndexedNotNull { index, instruction ->
            when (instruction) {
                is Mark -> Pair(index, instruction)
                else -> null
            }
        }.forEach {
            mark(it.second.label, it.first)
        }

        while (programCounter++ < (program.size - 1)) {
            val instruction = program[programCounter]

            if (instruction is Mark) continue

            instruction.execute(this)
        }
    }
}