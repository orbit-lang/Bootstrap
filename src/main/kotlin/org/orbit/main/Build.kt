package org.orbit.main

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.multiple
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.multiple
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.file
import com.github.ajalt.clikt.parameters.types.int
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject
import org.koin.core.context.loadKoinModules
import org.koin.core.context.startKoin
import org.koin.dsl.module
import org.orbit.core.CodeGeneratorQualifier
import org.orbit.core.DummyPhase
import org.orbit.core.components.CompilationEventBus
import org.orbit.core.components.CompilationScheme
import org.orbit.core.components.CompilationSchemeEntry
import org.orbit.core.getResult
import org.orbit.core.phase.CompilerGenerator
import org.orbit.frontend.MultiFileSourceProvider
import org.orbit.frontend.phase.CommentParser
import org.orbit.frontend.phase.Lexer
import org.orbit.frontend.phase.Parser
import org.orbit.frontend.rules.ProgramRule
import org.orbit.graph.phase.CanonicalNameResolver
import org.orbit.util.*
import java.io.File
import kotlin.time.ExperimentalTime
import kotlin.time.measureTime

object Build : CliktCommand(), KoinComponent {
    const val COMMAND_OPTION_LONG_MAX_CYCLES = "--max-cycles"
    const val COMMAND_OPTION_LONG_OUTPUT = "--output"
    const val COMMAND_OPTION_LONG_OUTPUT_PATH = "--output-path"
    const val COMMAND_OPTION_LONG_LIBRARY = "--library"
    const val COMMAND_OPTION_LONG_VERBOSE = "--verbose"
    const val COMMAND_OPTION_CODEGEN_TARGET = "--generate"

    const val COMMAND_OPTION_DEFAULT_MAX_CYCLES = 25

	private val invocation: Invocation by inject()
	private val compilerGenerator: CompilerGenerator by inject()
	private val compilationEventBus: CompilationEventBus by inject()

	data class BuildConfig(val maxDepth: Int, val productName: String, val outputPath: File)

	private val sources by argument(help = "Orbit source file to compile")
		.file()
		.multiple(true)

	private val output by option("-o", COMMAND_OPTION_LONG_OUTPUT, help = "Custom name for library product (default value = MyLibrary). Must start with a capital letter.")
		.default("MyLibrary")

	private val outputPath by option("-p", COMMAND_OPTION_LONG_OUTPUT_PATH, help = "Path where library product will be written to. Defaults to current directory.")
		.file()
		.default(File("."))

	private val libraryPaths by option("-l", COMMAND_OPTION_LONG_LIBRARY, help = "Path(s) to directories containing Orbit library products")
		.file()
		.multiple()

	private val verbose by option("-v", COMMAND_OPTION_LONG_VERBOSE, help = "Prints out detailed compiler events")
		.flag(default = false)

	private val maxDepth by option("-x", COMMAND_OPTION_LONG_MAX_CYCLES, help = "Sets the maximum allowed recursive cycles when resolving dependency graph")
		.int()
		.default(COMMAND_OPTION_DEFAULT_MAX_CYCLES)

	private val codeGenTarget by option("-g", COMMAND_OPTION_CODEGEN_TARGET, help = "Sets the target language generated by the code generator phase")
		.default("C")

	@ExperimentalTime
	override fun run() {
		println("Compilation completed in " + measureTime {
            try {
                startKoin {
                    modules(mainModule)
                }

                loadKoinModules(module {
                    single { BuildConfig(maxDepth, output, outputPath) }
                    single { CodeGeneratorQualifier.valueOf(codeGenTarget) }
                })

                if (!outputPath.isDirectory) {
                    throw invocation.make("Specified output path '${outputPath.absolutePath}' is not a directory")
                }

                // Creates an Orbit Library Directory
                val completeLibraryOutputDirectoryPath = outputPath.toPath()
                    .resolve(output)

                val completeLibraryOutputDirectory = completeLibraryOutputDirectoryPath.toFile()

                if (!completeLibraryOutputDirectory.exists()) {
                    completeLibraryOutputDirectory.mkdirs()
                }

                val orbitLibraryPath = completeLibraryOutputDirectoryPath.resolve("$output.orbl")
                val swiftLibraryPath = completeLibraryOutputDirectoryPath.resolve("$output.${codeGenTarget.lowercase()}")

                val importedLibs = mutableListOf<OrbitLibrary>()

                for (lpath in libraryPaths) {
                    if (lpath.isDirectory) {
                        val paths = lpath.listFiles(OrbitLibrary)
                            ?: continue

                        paths.forEach { println("Importing Orbit library '${it}'...") }
                        paths.map(OrbitLibrary.Companion::fromPath)
                            .forEach(importedLibs::add)
                    } else {
                        throw invocation.make("Library path provided via --library-path option must be a directory")
                    }
                }

                loadKoinModules(module {
                    single { ImportManager(importedLibs) }
                })

                // TODO - Platform should be derived from System.getProperty("os.name") or similar
                // TODO - Support non *nix platforms
                val sourceReader = MultiFileSourceProvider(sources)
                val dummyPhase = DummyPhase(invocation, sourceReader)

                // The first phase (CommentParser) needs an input, so we "cheat" here by inserting initial conditions
                invocation.storeResult("__source__", sourceReader)

                compilerGenerator["__source__"] = dummyPhase
                compilerGenerator[CompilationSchemeEntry.commentParser] = CommentParser(invocation)
                compilerGenerator[CompilationSchemeEntry.lexer] = Lexer(invocation)
                compilerGenerator[CompilationSchemeEntry.parser] = Parser(invocation, ProgramRule)
                compilerGenerator[CompilationSchemeEntry.canonicalNameResolver] = CanonicalNameResolver(invocation)
                compilerGenerator[CompilationSchemeEntry.typeSystem] = org.orbit.types.next.phase.TypeSystem //TypeSystem(invocation)
//                compilerGenerator[CompilationSchemeEntry.traitEnforcer] = TraitEnforcer()
//                compilerGenerator[CompilationSchemeEntry.mainResolver] = MainResolver

                compilationEventBus.events.registerObserver {
                    val printer = Printer(invocation.platform.getPrintableFactory())
                    val eventName = printer.apply(it.identifier, PrintableKey.Bold, PrintableKey.Underlined)

//					if (verbose) {
//						println("Compiler event: $eventName")
//					}
                }

                compilerGenerator.run(CompilationScheme)

//                val typeAssistant = invocation.getResult<TypeAssistant>("__type_assistant__")

//                println(typeAssistant.dump())

                val parserResult = invocation.getResult<Parser.Result>(CompilationSchemeEntry.parser)

                val orbitLibraryFile = orbitLibraryPath.toFile()

                if (!orbitLibraryFile.exists()) {
                    orbitLibraryFile.createNewFile()
                }

                val libraryExports = OrbitLibrary.fromInvocation(invocation)

                libraryExports.write(orbitLibraryFile)

                val swiftLibraryFile = swiftLibraryPath.toFile()

                if (!swiftLibraryFile.exists()) {
                    swiftLibraryFile.createNewFile()
                }

//                val codeWriter = CodeWriter(completeLibraryOutputDirectoryPath)
//
//                codeWriter.execute(parserResult.ast as ProgramNode)
            } catch (ex: Exception) {
                println(invocation.dumpWarnings())
                println(ex.message)
            }
        })
	}
}